#!/usr/bin/env python
import numpy, math, os
from csv import DictReader
from argparse import ArgumentParser, FileType
from sys import stdout, exit

class Colours:
    LOW = '\033[1;31m'
    MED = '\033[1;33m'
    NAN = '\033[0;90m'
    END = '\033[0m'

def getESS(data, burninPerc, thin=None):
    """Effective sample size, as computed by BEAST Tracer, stolen from biopy."""

    burnin = int(math.floor(burninPerc*len(data)/100.0))
    data = data[burnin:]

    if thin != None:
        data = data[0:len(data):max(len(data)/thin,1)]

    samples = len(data)

    assert len(data) > 1,"no stats for short sequences"

    maxLag = min(samples//3, 1000)

    gammaStat = [0,]*maxLag

    varStat = 0.0

    if type(data) != numpy.ndarray :
        data = numpy.array(data)

    normalizedData = data - data.mean()

    for lag in range(maxLag) :
        v1 = normalizedData[:samples-lag]
        v2 = normalizedData[lag:]
        v = v1 * v2
        gammaStat[lag] = sum(v) / len(v)

        if lag == 0 :
            varStat = gammaStat[0]
        elif lag % 2 == 0 :
            s = gammaStat[lag-1] + gammaStat[lag]
            if s > 0 :
                varStat += 2.0*s
            else:
                break

    if varStat > 0:
        return samples * gammaStat[0] / varStat
    else:
        return float("nan")

def colourizedString(string, ess, colours=False):
    if colours:
        if ess < 100.0:
            col = Colours.LOW
        elif ess < 200.0:
            col = Colours.MED
        elif math.isnan(ess):
            col = Colours.NAN
        else:
            col = ""

        return col + string + Colours.END

    else:
        return string

def formatESSList(essVals, colWidths, cWidth=None, colours=False):
    essString = ""
    charCount = 0
    for i in range(len(essVals)):
        ess = essVals[i]
        colWidth = colWidths[i]

        if i>0:
            essString += " "
            charCount += 1

        thisString = "{0:0.1f}".format(ess).ljust(colWidth)[:colWidth]
        if cWidth != None and charCount + len(thisString) > cWidth:
            thisString = thisString[:(cWidth - charCount)]
            essString += colourizedString(thisString, ess, colours=colours)
            return essString

        essString += colourizedString(thisString, ess, colours=colours)
        charCount += len(thisString)

    return essString

def getESSChar(ess, colours=False):
    if ess < 100.0:
        return colourizedString("!", ess, colours=colours)
    elif ess < 200.0:
        return colourizedString("*", ess, colours=colours)
    elif math.isnan(ess):
        return colourizedString("_", ess, colours=colours)

    return colourizedString("+", ess, colours=colours)

def formatESSKompressed(essVals, colours=False):
    essString = ""
    for i in range(len(essVals)):
        essString += getESSChar(essVals[i], colours=colours)

    minESS = min(filter(lambda x: not math.isnan(x), essVals))

    essString += " " + colourizedString("{0:0.1f}".format(minESS).ljust(10)[:10], minESS, colours=colours)

    return essString

### Main ###

def main():

    parser = ArgumentParser(description="Produce table of ESS values from one or more BEAST log files.",
            epilog="""ESS values smaller than 100 are considered very low and are highlited in red.
            Values between 100 and 200 are also fairly low and are highlighted in yellow.""")
    parser.add_argument("logs", metavar='log', type=FileType('r'), nargs='+',
            help="A BEAST parameter log file.")
    parser.add_argument("-d", "--delimiter", dest="delim", type=str, default="\t",
            help="Delimiter used to separate values of log file.")
    parser.add_argument("-b", "--burnin", type=float, default=10.0,
            help="Percentage of each log to skip to account for burn-in.")
    parser.add_argument("-s", "--sample", dest="sampleHeader", type=str, default="Sample",
            help="Name of samples/iterations column (case sensitive).")
    parser.add_argument("-c", "--cut", action='store_true',
            help="Cut unkompressed output to width of terminal window.")
    parser.add_argument("-n", "--no-colours", action='store_true',
            help="Disable colour output.")
    parser.add_argument("-k","--kompress", action='store_true',
            help="Represent each ESS value with a single coloured character.")
    parser.add_argument("-m","--min", action='store_true',
            help="Only display minimum (non-NaN) ESS over all parameters for each log.")
    parser.add_argument("-t","--thin", type=int,
            help="Thin the data to at most this many evenly-spaced samples before computing ESS.")

    args = parser.parse_args()

    fnames = [fp.name for fp in args.logs]
    fnamewidth = max([len(fname) for fname in fnames])

    # Disable cutting and colours if stdout isn't a terminal
    if not stdout.isatty():
        args.cut = False
        args.no_colours = True

    if stdout.isatty():
        cHeight, cWidth = os.popen('stty size', 'r').read().split()
        cWidth = int(cWidth)

    if args.kompress:
        thisLineIndex = 0

    params = None
    colWidths = None
    for log in args.logs:
        data = {}
        rdr = DictReader(filter(lambda line: not line.strip().startswith("#"), log), delimiter=args.delim)
        if params == None:
            params = filter(lambda f: len(f)>0 and f != args.sampleHeader, rdr.fieldnames)
            colWidths = [max(10, len(p)) for p in params]

            if (not args.kompress) and (not args.min):
                header = "LOG".ljust(fnamewidth) + " "
                header += " ".join([params[i].ljust(colWidths[i])[:colWidths[i]] for i in range(len(params))])

                if args.cut:
                    print header[:cWidth]
                else:
                    print header

                stdout.flush()

            if args.kompress and stdout.isatty():
                entryWidth = fnamewidth + 1 + len(params) + 11
                entriesPerLine = cWidth/entryWidth
                thisEntry = 0

        for param in params:
            data[param] = []

        for row in rdr:
            for param in params:
                data[param].append(float(row[param]))

        essVals = []
        for param in params:
                essVals.append(getESS(data[param], args.burnin, thin=args.thin))

        stdout.write(log.name.ljust(fnamewidth) + " ")
        if args.min:
            print "{0:0.1f}".format(min(filter(lambda x: not math.Yisnan(x), essVals)))
        elif args.kompress:
            if stdout.isatty() and thisEntry > 0:
                stdout.write(" ")

            stdout.write(formatESSKompressed(essVals, colours=not args.no_colours))

            if stdout.isatty():
                thisEntry += 1
                if thisEntry == entriesPerLine:
                    thisEntry = 0
                    print
            else:
                print
        else:
            if args.cut:
                print formatESSList(essVals, colWidths, cWidth - fnamewidth - 1, colours=not args.no_colours)
            else:
                print formatESSList(essVals, colWidths, colours=not args.no_colours)

        stdout.flush()

    if args.kompress and stdout.isatty() and thisEntry < entriesPerLine:
        print

# Call main from here, catching KeyboardInterrupt to
# avoid unsightly stack traces.

if __name__ == '__main__':

    try:
        main()
    except KeyboardInterrupt:
        exit(1)

    exit(0)
